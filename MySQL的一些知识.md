---
title: MySQL的一些知识
date: 2016-06-22 18:31:05
tags:
	- MySQL
categories:
	- 数据库
---

# 1. 读写锁

假设某个客户正在读取邮箱，同时另一个用户正在试图删除编号为25的邮件，会出现什么情况？结论是不确定。读的客户可能会报错退出，也可能读到不一致的邮箱数据。
如果把上述的邮箱当成数据库的一张表，把邮件当成表中的一条记录，就很容易发现同样的问题在数据库中仍然存在。
解决这类经典问题的方法就是并发控制，其实非常简单。在处理并发读或者写的时候，可以通过实现一个由两种类型锁组成的锁系统来解决问题。这两类锁通常被陈伟共享锁和排他锁，也叫读锁和写锁。
<!--more-->
这里不讨论锁的具体实现，描述一下锁的概念如下：**读锁是共享的，或者说是相互不阻塞的。多个客户可以在同一时间同时读取同一个资源而互不干扰。写锁是排他的，也就是说一个写锁会阻塞其它的读锁和写锁。**只有这样，才能确保在给定的时间里，只有一个用户能执行写入，并防止其它用户读取正在写入的资源。

# 2. 锁粒度

一种提高共享资源并发性的方式就是让锁定对象更加具有选择性。也就是说，**尽量只锁定需要修改的部分数据，而不是所有的资源。**更理想的方式是，只对会修改的数据片进行精确的锁定。**任何时候，在给定的资源上，锁定的数据量越少，则系统的并发程度越高。**
需要注意的是，加锁也需要消耗资源。锁的各种曹锁都会增加系统的开销。如果系统花费大量的时间来管理锁，而不是数据的存取，那么系统的性能很有可能因此受到影响。
**所谓的锁策略，就是在锁的开销和数据的安全性之间寻求平衡，**这种平衡当然也会影响性能。MySQL提供了多种选择。每种存储引擎都可以实现自己的锁策略和锁粒度。将锁粒度固定在某个级别，可以为某些特定的场景提供更好的性能，但同时会失去对另外一些场景更好的支持。

## 2.1. 表锁

**表锁是MySQL中最基本的锁策略，并且是开销最小的策略。它会锁定整张表，一个用户在对表进行写入操作，需要先获得整张表的写锁，这回阻塞其它用户对该表的所有读写操作。**

# 2.2. 行级锁

行级锁可以最大程度地支持并发处理，同时也带来了最大的锁开销。在InnoDB和XtraDB以及一些其它的存储引擎中都实现了行级锁。

# 3. 事务

事务就是一组原子性的SQL查询，或者说是一个独立的工作单元。事务内的语句，要么全部执行成功，要么全部回滚。事务有以下几个特性：

1. 原子性：一个事务必须被视为一个不可分割的最小工作单元，整个事务要么全部提交成功，要么全部回滚。
2. 一致性：数据库总是从一个一致性状态转换到另一个一致性状态。
3. 隔离性：通常来说，一个事务所做的修改在最终提交以前，对其它事务是不可见的。
4. 持久性：一旦事务提交，对数据库所做的修改就是永久的。

## 3.1. 事务隔离级别

1. READ UNCOMMITTED（未提交读）：事务中的修改，即使没有提交，对其它事务也是可见的。事务可以读取未提交的数据，也被称为脏读。
2. READ COMMITTED（提交读）：大多数数据库默认的隔离级别都是这个，但MySQL不是。在这个隔离级别下，一个事务所做的修改在被提交以前，对其它事务是不可见的。这种隔离级别也叫不可重复读，因为两次执行同样的查询，得到的结果可能不一样。
3. REPEATABLE READ（可重复读）：解决了脏读的问题，确保同一个事务中多次读取相同的记录结果是一样的，但是无法解决幻读问题。当一个事务读取某个范围内的记录时，另一个事务插入了几条新纪录，再次读取时就会出现几行幻行，这就是幻读。这是MySQL的默认隔离级别。
4. SERIALIZABLE（可串行化）：最高的隔离级别。它通过强制事务串行执行，避免了前面说的幻读问题。该级别会在每一行数据上都加锁，所以可能导致大量的超时和锁争用问题。

## 3.2. 事务日志

事务日志可以提高事务的效率。使用事务日志，存储引擎可以在修改表数据时只需要修改内存中的拷贝，在把该行记录到持久在硬盘上的事务日志中，而不需要每次都修改磁盘中的数据本身，之后内存中的数据再慢慢刷入硬盘。

## 3.3 MySQL中的事务

MySQL默认采用自动提交模式。也就是说，如果不是显示的开始一个事务，则每个查询都被当做一个事务执行提交操作，可以使用AUTOCOMMIT来启用或者禁用自动提交模式。
当禁用自动提交模式时，所有的查询都是在一个事务中，直到显示地执行COMMIT或者ROLLBACK回滚，该事务结束，同时又开始了一个新事务。

# 4. 多版本并发控制

MySQL的大多数事务型存储引擎实现的都不是简单的行级锁，一般都同时实现了多版本并发控制（MVCC）。
MVCC的实现，是通过保存数据再某个时间点的快照来实现的。也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间点不同，同一时刻看到的数据可能是不一样的。
InnoDB的MVCC，是通过在每行记录后面保存两个隐藏列来实现的。这两个列，一个保存了行的创建时间，一个保存了行的过期时间。当然保存的并不是实际的时间值，而是系统版本号。每开始一个新的事务，系统版本号都会自动递增，事务开始时刻的系统版本号会作为事务的版本号。在可重复读的隔离级别下，MVCC操作如下：

1. SELECT：InnoDB只会查找版本号早于当前事务版本号的数据行，删除时行的过期版本号要么未定义，要么大于当前事务版本号。
2. INSERT：为插入的每一行保存当前系统版本号为行版本号。
3. DELETE：为删除的每一行保存当前系统版本号为行删除标识。
4. UPDATE：插入一行新纪录保存当前系统版本号为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。
