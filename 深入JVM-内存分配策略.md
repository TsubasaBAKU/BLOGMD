---
title: '深入JVM:内存分配策略'
date: 2016-07-21 20:05:04
tags:
	- JVM
	- 内存分配
	- 垃圾回收
categories:
	- JAVA
---
# 对象已死吗？

垃圾回收期在回收对象前，首先要确定的就是这些对象之中哪些还存活着，哪些已经死去了。
<!--more-->

## 引用计数法

给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1，当引用失效时，计数器就减1。当计数器变为0时，对象将不能被使用了，则对象被宣判死刑。
但是，主流的Java虚拟机中都没有选择引用计数法来进行内存管理，其中最主要的原因就是**它很难解决对象之间相互引用的问题。**设想两个对象objA和objB都有字段instance，又有objA.instance=objB,objB.instance=A,除此之外，这两个对象没有任何引用。但实际上，这个对象已经无法再被访问，但在引用计数法下，这个对象扔被当做是不可回收的对象。

## 可达性分析法

这个算法的实质就是通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为“引用链”。当一个对象到GC Roots没有任何引用链可达时，这个对象将被判定为可回收的对象。
在Java中，能够作为GC Roots对象包括以下几种：

1. 虚拟机栈（栈帧的本地变量表）中引用的对象。
2. 方法区中静态属性引用的对象。
3. 方法区中常量引用的对象
4. Native方法引用的对象。

![cmd-markdown-logo](https://raw.githubusercontent.com/TsubasaBAKU/BLOGIMG/master/可达性分析.png)

## 再谈引用

Java在JDK1.2之前对引用的定义很传统：如果reference类型的数据中存储的值代表的是另一块内存的其实地址，就称这块内存代表着一个引用。这种定义太过于狭隘，我们希望能够描述这样的一类对象：当内存空间还足够时，则能保留在内存之中；如果内存空间在进行垃圾回收后还是非常紧张，则可以抛弃折现对象。在JDK1.2之后，Java对引用的内容进行的扩张：

1. 强引用：就是在程序中普遍存在的，类似“Object obj = new Object（）”这样的代码，只要强引用还存在，垃圾收集器就永远不会回收掉这些对象。
2. 软引用：描述一些还有用但非必须的对象。对于软引用关联的对象，**在系统将要发生内存溢出之前，将会把这些对象纳入回收范围之中进行第二次回收，若回收后还是没有足够的内存，则抛出内存溢出异常。**
3. 弱引用：用来描述非必须的对象。比软引用更弱一些，弱引用关联的对象只能存活到垃圾回收发生之前，在垃圾回收发生时，无论内存是否充足，这些对象都会被回收掉。
4. 虚引用：最弱的一种引用关系。一个对象是否有虚引用存在对齐生存时间完全不会有影响，也无法通过虚引用来取得一个对象的实例。设置虚引用的唯一目的就是在这个对象被垃圾回收的时候得到一个系统通知。

## 生存还是死亡

即使在可行性分析中不可达的对象，也并不是一定会被回收的，要真正确定回收一个对象，至少要经历两次标记过程：

1. 在经过可达性分析后判定为不可达的对象，将会被第一次标记并进行一次筛选，**筛选的条件是此对象是否有必要执行finalize（）方法。**
2. 当对象没有覆盖finalize（）方法或者已经被虚拟机调用过了此方法，虚拟机将进行第二次标记。

若对象被判定有必要执行finalize（）方法，那么这个对象将会被放入一个叫F-Queue的队列中，稍后将由一个由虚拟机自动建立的，低优先级的线程去触发这个finalize方法，但并不会等待它运行结束。finalize（）方法是对象逃脱回收的最后一次机会，稍后虚拟机将会对F-Queue中的对象进行二次标记，如果对象要在finalize（）方法中拯救自己，只需要将自己与引用链中的任何一个对象关联起来即可。**任何对象的finalize（）方法都只会被虚拟机调用一次。**

# 垃圾收集算法

## 标记-清除算法

标记-清除算法是最基本的手机算法，分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收。
它的不足之处主要有两个：一个是效率问题，标记和清除两个过程的效率都不高；第二个是空间问题，回收之后可能会产生大量的内存碎片。
![cmd-markdown-logo](https://raw.githubusercontent.com/TsubasaBAKU/BLOGIMG/master/标记-清除算法.png)

## 复制算法

为了解决效率问题，复制算法出现了：将可用的内存容量分为大小相等的两块，每次只使用其中的一块，当这一块用完了，就将还存活的对象复制到另一块上面，然后把已经使用过的那一块内存一次性全部清理掉。这样使得每次回收都是针对每个半区，就不会出现过多碎片的情况了。
![cmd-markdown-logo](https://raw.githubusercontent.com/TsubasaBAKU/BLOGIMG/master/复制算法.png)
研究表明，新生代中98%的对象都是“朝生夕死”，所以并不需要按照1:1的比例来划分可用内存，而是将内存划分成一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一个Survivor。当回收时，存活的对象复制到另一个Survivor中，最后清理掉已经使用的空间。

## 标记-整理算法

复制算法在对象存活较多的时候就要进行较多的复制，效率就会变低。标记整理算法的标记过程与标记清除算法一样，但后续步骤㔻直接对内存进行回收，而是将存活的对象全部向一端移动，然后清理掉边界意外的内存。
![cmd-markdown-logo](https://raw.githubusercontent.com/TsubasaBAKU/BLOGIMG/master/标记整理算法.png)