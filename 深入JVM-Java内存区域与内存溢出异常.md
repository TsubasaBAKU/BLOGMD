---
title: '深入JVM:Java内存区域与内存溢出异常'
date: 2016-07-18 15:46:52
tags:
	- JVM
	- 内存区域
	- 内存溢出异常
categories:
	- JAVA
---
在《深入理解JAVA虚拟机》一书中，前几章的开头都写着同一段话：“java与c++之间有一堵由内存动态分配和垃圾收集技术所围城的‘高墙’，墙外的人想进去。墙里面的人想出来”。
<!--more-->

# 运行时数据区

  Java虚拟机将它管理的内存划分成不同的区域，这些区域有的被所有线程共享，有的是线程私有，如图：
![cmd-markdown-logo](https://raw.githubusercontent.com/TsubasaBAKU/BLOGIMG/master/HotSpot内存图.png)

## 程序计数器

  程序计数器（PC）是一块较小的内存空间，它可以看做是当前线程执行的字节码行号的指示器。由于java虚拟机的多线程是通过线程轮流切换并分配处理器时间的方式来执行的，在任何一个确定的时刻，一个处理器都只会执行一个线程。因此，线程切换后为了能够恢复到正确的位置，每个线程都要有一个独立的程序计数器，各个线程的程序计数器独立存储，相互不影响，所以程序计数器这块内存是**线程私有的**。

## Java虚拟机栈

与程序计数器一样，虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行时都会创建一个栈帧，这个栈帧用于存储局部表量表，操作数栈，动态连接，方法出口等信息。每一个方法从调用到执行完的过程，对应着一个栈帧在虚拟机栈中进栈和出栈的过程。
这个区域规定了两种异常情况：

1. 如果线程请求的栈深度大于虚拟机所允许的深度，就会抛出StackOverflowError异常；
2. 如果虚拟机栈可以动态扩展，扩展时无法申请到足够的空间，就会抛出OutOfMemoryError异常。

## 本地方法栈

本地方法栈与虚拟机栈发挥的作用十分类似，但本地方法是为虚拟机执行Native方法服务的，有的虚拟机（如HotSpot）就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，这个区域也有StackOverflowError和OutOfMemoryError异常。

## Java堆

与程序计数器和虚拟进栈不同的是，**堆是所有线程所共享的一块区域**。**这个区域的唯一目的就是存放实例对象**。从内存分配的角度来看，由于现在的收集器基本都采用分代收集算法，所以Java堆又可以划分成为新生代和老年代，新生代又可以划分成为Eden区域，From Survivor区域和To Survivor区域，划分的目的是为了更好的垃圾回收，但是无论哪个区域，存储的都是对象实例。
Java堆可以处在不连续的内存空间中，只要逻辑上是连续的即可，可以是固定大小的，也可以是可扩展的。当对象实例没有完成实例分配，并且堆无法扩展时，就会抛出OutOfMemoryError异常。

## 方法区

首先方法区和Java堆一样，是所有线程共享的区域。它用于存储虚拟机加载的类信息，常量，静态变量等数据。当方法区的内存无法满足内存分配需求时，会抛出OutOfMemoryError异常。

## 运行时常量池

运行时常量池是方法区的一部分，Class文件中有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容在类加载后进入方法区的运行时常量池。

# HotSpot对象

## 对象的创建

1. 当虚拟机遇到一条new指令是，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化过。如果没有，那么限制性这个类的相应的加载过程。
2. 在类加载完成后，将为新生对象分配空间。对象所需内存大小在类加载完成后即可完全确定，为对象分配空间的任务等同于把一块与对象大小相等的内存从堆中划分出来。假设Java堆中的内存是绝对工整的，就是说所有用过的内存都放在一边，没有用过的都放在另一边，中间放着一个指示器作为分界点。那么分配内存的过程其实就是将指示器向空闲内存的一边移动对象大小的距离即可，这种分配方式称为“指针碰撞”。若堆内存不工整，那么虚拟机必须维护一个列表，记录哪些内存是可用的，哪些内存已经使用过了，在分配时候从空闲内存中找出一块足够大的给对象，这种分配方式称为“空闲列表”。

除了如何划分内存空间之外，另一个需要考虑的问题就是对象创建在虚拟机中是一个非常频繁的行为包括两个 ，即使是一个简单的指针移动，在并发情况下也是不安全的。这种问题有两种解决方案：

1. 将移动指针的操作进行同步处理；
2. 把内存分配的动作按照每个线程划分在不同的区域中，即每个线程在Java堆预先划分出一块内存区域，称为本地线程分配缓冲（TLAB），哪个线程要分配内存，就在哪个线程的TLAB上分配。

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值，这一步操作保证了对象的实例字段可以不赋初值就直接使用。至于这个对象是哪个类的实例，如何找到元数据信息，对象的哈希码等信息都存放在对象的对象头之中。

上述工作完成后，一个新的对象实际上就已经产生了，但是需要执行init把对象按照程序员的意向初始化，这样才算完全产生一个对象。

## 对象的内存布局

在HotSpot虚拟机中，对象在内存中的存储布局分为三个部分：对象头，实例数据和对齐填充。
对象头包括两部分信息，第一部分用于存储对象运行时数据如哈希码，GC年代，锁状态标识等，另一部分是类型指针，即对象指向它的类元数据的指针，**虚拟机通过这个指针确定这个对象是哪个类的实例**。
实例部分存储的是对象真正有效的信息，也就是在程序代码中所定义的各种类型字段的内容。
对齐填充并不是必然的存在，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot的自动内存管理系统要求对象的起始地址必须是8字节的整数倍，当对象实例数据部分没有对骑士，就需要通过对齐填充来不全。

## 对象的访问定位

Java程序需要通过栈上的reference数据来操作堆上的具体对象，由于reference在Java虚拟机规范中值规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位，访问堆中的具体位置，所以对象访问方式也是取决于虚拟机具体实现的。目前主流的方式是句柄和直接指针。

1. 句柄：Java堆中将会划分出来一块内存作为句柄池，reference中存储的是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址。
![cmd-markdown-logo](https://raw.githubusercontent.com/TsubasaBAKU/BLOGIMG/master/句柄访问对象.png)

2. 如果是直接指针访问，那么reference中存放的就是对象地址。
3. ![cmd-markdown-logo](https://raw.githubusercontent.com/TsubasaBAKU/BLOGIMG/master/直接指针访问对象.png)

两种访问对象的方式各有优势，使用句柄来访问最大的好处就是reference中存储的句柄地址是稳定的，不会随着对象的移动而移动；用直接指针访问的最大好处就是访问速度快，就HotSpot而言，它是使用直接指针方式访问数据的。8



